{% assets "threejs_libs" %}
    <script type="text/javascript" src="{{ ASSET_URL }}"></script>
{% endassets %}

<div id="stl_container" >
</div>

<script>
/*
    var container, stats;

    var camera, cameraTarget, scene, renderer;
    var objects = [], plane;;

    var raycaster = new THREE.Raycaster();
    var mouse = new THREE.Vector2(),
    offset = new THREE.Vector3(),
    INTERSECTED, SELECTED;

    init();
    animate();

    function init() {

        container = document.getElementById( 'stl_container' );
        //document.body.appendChild( container );

        camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 0.1, 1000 );
        camera.position.set( 150, -50, 150 );

        controls = new THREE.TrackballControls( camera );
        controls.rotateSpeed = 1.0;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;
        controls.noZoom = false;
        controls.noPan = false;
        controls.staticMoving = true;
        controls.dynamicDampingFactor = 0.3;

        scene = new THREE.Scene();

        var loader = new THREE.STLLoader();

        // Colored binary STL
        loader.load('./stl/3DBenchy.stl', function ( geometry ) {
            var material = new THREE.MeshPhongMaterial( { color: 0xECC459, specular: 0x111111, shininess: 200 } );

            var mesh = new THREE.Mesh( geometry, material );
            mesh.position.set( 0, -20, 0 );
            mesh.rotation.set( - Math.PI / 6, Math.PI / 6, 0 );
            mesh.scale.set( 1.5, 1.5, 1.5 );
            mesh.castShadow = true;
            scene.add( mesh );

            objects.push( mesh );
        });


        plane = new THREE.Mesh(
            new THREE.PlaneBufferGeometry( 2000, 2000, 8, 8 ),
            new THREE.MeshBasicMaterial( { visible: false } )
        );
        scene.add( plane );

        // Lights
        var directionalLight=new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position=camera.position;
        scene.add(directionalLight);

        // renderer
        renderer=new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight / 1.5);
        container.appendChild( renderer.domElement );

        renderer.domElement.addEventListener( 'mousemove', onDocumentMouseMove, false );
        renderer.domElement.addEventListener( 'mousedown', onDocumentMouseDown, false );
        renderer.domElement.addEventListener( 'mouseup', onDocumentMouseUp, false );
        //
        window.addEventListener( 'resize', onWindowResize, false );
	}

    function addLight(x, y, z, color, intensity){
        var directionalLight=new THREE.DirectionalLight(color, intensity);
        directionalLight.position.set(x, y, z)
        scene.add(directionalLight);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight/ 2 );
    }

    function animate() {
        requestAnimationFrame( animate );
        render();
    }

    function render() {
        var timer = Date.now() * 0.0005;
        r=150;
        camera.position.x=150;
        camera.position.z=150;
        camera.position.y=-150;
        camera.lookAt(scene.position);
        renderer.render(scene, camera);
        renderer.setClearColor(0xf5f5f5, 1);
    }


    function onDocumentMouseMove( event ) {
        event.preventDefault();
        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
        //
        raycaster.setFromCamera( mouse, camera );
        if ( SELECTED ) {
            var intersects = raycaster.intersectObject( plane );
            if ( intersects.length > 0 ) {
                SELECTED.position.copy( intersects[ 0 ].point.sub( offset ) );
            }
            return;
        }
        var intersects = raycaster.intersectObjects( objects );
        if ( intersects.length > 0 ) {
            if ( INTERSECTED != intersects[ 0 ].object ) {
                if ( INTERSECTED ) INTERSECTED.material.color.setHex( INTERSECTED.currentHex );
                INTERSECTED = intersects[ 0 ].object;
                INTERSECTED.currentHex = INTERSECTED.material.color.getHex();
                plane.position.copy( INTERSECTED.position );
                plane.lookAt( camera.position );
            }
            container.style.cursor = 'pointer';
        } else {
            if ( INTERSECTED ) INTERSECTED.material.color.setHex( INTERSECTED.currentHex );
            INTERSECTED = null;
            container.style.cursor = 'auto';
        }
    }

    function onDocumentMouseDown( event ) {
        event.preventDefault();
        raycaster.setFromCamera( mouse, camera );
        var intersects = raycaster.intersectObjects( objects );
        if ( intersects.length > 0 ) {
            controls.enabled = false;
            SELECTED = intersects[ 0 ].object;
            var intersects = raycaster.intersectObject( plane );
            if ( intersects.length > 0 ) {
                offset.copy( intersects[ 0 ].point ).sub( plane.position );
            }
            container.style.cursor = 'move';
        }
    }

    function onDocumentMouseUp( event ) {
        event.preventDefault();
        controls.enabled = true;
        if ( INTERSECTED ) {
            plane.position.copy( INTERSECTED.position );
            SELECTED = null;
        }
        container.style.cursor = 'auto';
    } */
</script>